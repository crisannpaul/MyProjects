{"ast":null,"code":"import { isVisible } from '../util/TickUtils';\nimport { getEveryNthWithCondition } from '../util/getEveryNthWithCondition';\nexport function getEquidistantTicks(sign, boundaries, getTickSize, ticks, minTickGap) {\n  var result = (ticks || []).slice();\n  var initialStart = boundaries.start,\n      end = boundaries.end;\n  var index = 0; // Premature optimisation idea 1: Estimate a lower bound, and start from there.\n  // For now, start from every tick\n\n  var stepsize = 1;\n  var start = initialStart;\n\n  var _loop = function _loop() {\n    // Given stepsize, evaluate whether every stepsize-th tick can be shown.\n    // If it can not, then increase the stepsize by 1, and try again.\n    var entry = ticks === null || ticks === void 0 ? void 0 : ticks[index]; // Break condition - If we have evaluate all the ticks, then we are done.\n\n    if (entry === undefined) {\n      return {\n        v: getEveryNthWithCondition(ticks, stepsize)\n      };\n    } // Check if the element collides with the next element\n\n\n    var i = index;\n    var size;\n\n    var getSize = function getSize() {\n      if (size === undefined) {\n        size = getTickSize(entry, i);\n      }\n\n      return size;\n    };\n\n    var tickCoord = entry.coordinate; // We will always show the first tick.\n\n    var isShow = index === 0 || isVisible(sign, tickCoord, getSize, start, end);\n\n    if (!isShow) {\n      // Start all over with a larger stepsize\n      index = 0;\n      start = initialStart;\n      stepsize += 1;\n    }\n\n    if (isShow) {\n      // If it can be shown, update the start\n      start = tickCoord + sign * (getSize() / 2 + minTickGap);\n      index += stepsize;\n    }\n  },\n      _ret;\n\n  while (stepsize <= result.length) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n\n  return [];\n}","map":null,"metadata":{},"sourceType":"module"}